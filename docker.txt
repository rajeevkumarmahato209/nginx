Run Image directly from CLI
-------------------------------------
docker run -d --name <name>  -e USERNAME=<***> -e  PASSWORD=<***>  --network <****> 

 Running Container
--------------------------------
Rename
docker rename my-new-container my-existing-container

Run Multiple Commands
docker exec -it <container_id> sh -c "apt-get update && apt-get install -y curl && echo 'Installation complete'"


Installation
-------------------------------
1. Docker
-----------------------
sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get update
sudo apt-get install docker-ce
docker --version

Manage Docker as a Non-root User: 
sudo usermod -aG docker $USER
sudo chown root:docker /var/run/docker.sock
sudo chmod 777 /var/run/docker.sock


install by script
------------------------
curl -fsSL https://get.docker.com -o get-docker.sh
 sudo sh get-docker.sh


Another way
---------------------
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin



2.Docker-compose
----------------------
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                                                        or
sudo wget "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -O /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version






3. Remove Docker
-------------------
sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras
sudo rm -rf /var/lib/docker
sudo rm -rf /var/lib/containerd








1.install package inside image
---------------------------------------
For Debian-based images (e.g., Ubuntu):

FROM ubuntu:latest
RUN apt-get update && apt-get install -y <package-name>


For Alpine-based images:

FROM alpine:latest
RUN apk add --no-cache <package-name>


For Red Hat-based images (e.g., CentOS, Fedora):

FROM centos:latest
RUN yum install -y <package-name>

2. Docker build command
---------------------------------
docker build -t <image-name>:<tag> . or -f dockerfile


3. How to write Dockerfile
------------------------------------
# Use the official Node.js image as a base
FROM node:14

# Set the working directory
WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code
COPY . .

# Expose port 3000
EXPOSE 3000

# Define the command to run the application
CMD ["node", "app.js"]



4. How to write docker-compose file
------------------------------------------
version: '3.8'

services:
  web:
    image: node:14
    container_name: web
    working_dir: /app
    volumes:
      - ./app:/app
    ports:
      - "3000:3000"
    depends_on:
      - db
    command: ["node", "server.js"]
    networks:
      - my-network

  db:
    image: mongo:latest
    container_name: mongo
    volumes:
      - mongodb_data:/data/db
    ports:
      - "27017:27017"
    networks:
      - my-network

volumes:
  mongodb_data:
networks:
  my-network:
    driver: bridge

docker compose command
----------------------------------

docker-compose up or -f docker-compose.yaml
docker-compose up -f docker-compose.yaml -d
docker-compose down -f docker-compose.yaml 
docker-compose logs -f docker-compose.yaml







compose file for db
-----------------------
version: ’2’
services:
db:
image: mysql:5.7
volumes:db_data:/var/lib/mysql
restart: always
environment:
MYSQL_ROOT_PASSWORD: WordPress
MYSQL_DATABASE: WordPress
MYSQL_USER: WordPress
MYSQL_PASSWORD: WordPress
WordPress:
depends_on:
- DB
image: WordPress:latest
ports:
- "8000:80"
restart: always
environment:
WORDPRESS_DB_HOST: db:3306

WORDPRESS_DB_PASSWORD: wordpress
volumes:
db_data:






error
----------------
docker-compose --- segementation error then reinstall it using below command
sudo curl -L "https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d\" -f4)/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose











5. Docker – USER Instruction
-----------------------------
in dockerfile add below things
---------------------------------
FROM ubuntu:latest
RUN apt-get -y update
RUN groupadd -r user && useradd -r -g user user
USER user


to se the users, exec inside the containers and run "id" commands


6. Docker commit
-----------------------------------------------------
Commit with default settings
docker commit <container_id> <new_image_name>

Commit with Author Information
docker commit -a "Author Name" <container_id> <new_image_name

Commit with a commit message
docker commit -m "Added new features" <container_id> <new_image_name>

Commit with changes Applied
docker commit --change="ENV DEBUG=true" <container_id> <new_image_name>



7. Docker tag
------------------------
tag by using existing image
docker tag <imageId> <imageName>/<tagName>

tag by using existing nameand versionTag
sudo docker tag <imageName:tag> <newImageName>:<tagName>

Multiple tag to same image
------------------------------------
docker build -t gfg/gfg_app: 1 -t gfg/gfg_webapp: 1





8. Dcker volumes
-----------------------
display all volumes
docker volume ls

create volume
docker volume create geeksforgeeks

Inspect volume
docker volume inspect geeksforgeeks

mounting - Start a Container With a Volume
docker run -it -v geeksforgeeks:/shared-volume --name my-container-01 ubuntu

same volume assign to another container
sudo docker run -it -v geeksforgeeks:/shared-volume --name my-container-02 ubuntu

Remove volume
docker volume rm volume_name_or_id


Use a Volume With Docker Compose
services:
  frontend:
    image: node:lts
    volumes:
      - mongovol:/data/db
volumes:
  mongovol:


Add volume to running container
$ docker commit 5a8f89adeead newimagename
$ docker run -ti -v "$PWD/somedir":/somedir newimagename /bin/bash
docker run -d --name my-new-container \
--volumes-from my-existing-container \
-v my-new-volume:/path/to/new/volume \
my-image


docker stop my-existing-container
docker rm my-existing-container






NFS Volume


version: '3'
services:
  nfs-server:
    image: tomact:latest
    container_name: nfs_container
    volumes:
      - /data:/nfs_share

  nfs-client:
    image: busybox
    container_name: nfs_client
    command: tail -f /dev/null
    volumes:
      - nfs-data:/data

volumes:
  nfs-data:
    driver_opts:
      type: nfs




  9. Dcker CP
  --------------------
  Docker Copy Files from Host To Container
  docker cp ~/Desktop/to-be-copied.txt 135950565ad8:/to-be-copied.txt

  Host files to Docker Container using cat Command
  docker exec -i <container name or container ID> sh -c 'cat > <Container path>' < <Host path>


Docker Copy Files Container To Host
docker cp 135950565ad8:/geeksforgeeks.txt ~/Desktop/geeksforgeeks.txt



10. Docker Networking
----------------------------
Create a Bridge Network
docker network create my_bridge_network

List Docker Networks
docker network ls

Inspect a Docker Network
docker network inspect my_bridge_network

Run a Container on a Specific Network
docker run --network my_bridge_network nginx

Connect a Container to a Network
docker network connect my_bridge_network my_container

Disconnect a Container from a Network
docker network disconnect my_bridge_network my_container


how to connect two container and test it ?
docker network create my_bridge_network
docker run -d --name nginx-server --network my_bridge_network nginx
docker run -it --name alpine-client --network my_bridge_network alpine sh
ping nginx-server




Static ip
$ docker network create --subnet=10.5.0.0/16 custom_net

$ docker run --detach --net custom_net --ip 10.5.0.5 -p 3306:3306 --mount source=db,target=/var/lib/mysql -e MYSQL_ROOT_PASSWORD=password mysql:latest
$ cat docker-compose.yml
services:
  db:
    container_name: mysql_db
    image: mysql:latest
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_ROOT_HOST=10.5.0.1
    ports:
      - 3306:3306
    volumes:
      - db:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      custom_net:
        ipv4_address: 10.5.0.5

volumes:
  db:
    driver: local

networks:
  custom_net:
    driver: bridge
    ipam:
      config:
        - subnet: 10.5.0.0/16
          gateway: 10.5.0.1

11. Private Repo
--------------------------
docker run -d -p 5000:5000 --name registry:2
docker push localhost:5000/mysql:latest



12. Docker Build
---------------------------
Multi-Stage Build
FROM node:14-alpine as base

WORKDIR /src
COPY package.json package-lock.json /src/
EXPOSE 3000

FROM base as production
ENV NODE_ENV=production
RUN npm ci
COPY . /src
CMD ["node", "bin/www"]

FROM base as dev
ENV NODE_ENV=development
RUN npm install -g nodemon && npm install
COPY . /src
CMD ["nodemon", "bin/www"]



13. Running Multiple Services
----------------------------------------
start-services.sh
#!/bin/bash

# Start MySQL
service mysql start

# Start Nginx
nginx -g 'daemon off;'




Dockerfile
COPY start-services.sh /usr/local/bin/start-services.sh
RUN chmod +x /usr/local/bin/start-services.sh

CMD ["/usr/local/bin/start-services.sh"]



docker build -t multi-service-app .
docker run -d -p 80:80 -p 3306:3306 multi-service-app



